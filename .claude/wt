#!/usr/bin/env bash
#
# wt - Git worktree manager for parallel Claude Code development
#
# Commands:
#   new   Create a new worktree with auto-sequenced branch name
#   rm    Remove a worktree and its branch
#   ls    List all worktrees
#
# Usage:
#   wt new -i <initials> [options] [description]
#   wt rm [options] <worktree-path-or-name | self>
#   wt ls
#
# Examples:
#   wt new -i mh                      # Creates mh/260113/01
#   wt new -i mh auth                 # Creates mh/260113/01-auth
#   wt new -i mh -l api-refactor      # Creates worktree and launches Claude
#   wt rm mh-260113-01                # Removes worktree by name
#   wt rm self                        # Removes current worktree
#   wt rm -f self                     # Force remove current worktree
#   wt ls                             # Lists all worktrees

set -euo pipefail

# ------------------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------------------

REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)" || {
  echo "error: not inside a git repository" >&2
  exit 1
}

ENV_FILES=(
  "shared/fpna/scripts/.env"
  "shared/fpna/.env"
  "apps/web/.env"
  "apps/sheets-extension/.env"
)

# ------------------------------------------------------------------------------
# Common Functions
# ------------------------------------------------------------------------------

die() {
  echo "error: $*" >&2
  exit 1
}

usage() {
  sed -n '2,/^set -euo/p' "$0" | sed '/^set -euo/d; s/^# \?//'
  exit 0
}

usage_new() {
  cat <<'EOF'
wt new - Create a new worktree

Usage:
  wt new -i <initials> [options] [description]

Options:
  -i, --initials INITIALS   Your initials (required)
  -l, --launch              Launch Claude Code in new iTerm2 tab
  -h, --help                Show this help

Naming Convention:
  Branch: {initials}/{YYMMDD}/{sequence}[-description]
  Directory: {initials}-{YYMMDD}-{sequence}[-description]

Examples:
  wt new -i mh                # Creates mh/260113/01
  wt new -i mh auth           # Creates mh/260113/01-auth
  wt new -i mh -l feature     # Creates and launches Claude
EOF
  exit 0
}

usage_rm() {
  cat <<'EOF'
wt rm - Remove a worktree

Usage:
  wt rm [options] <worktree-path-or-name | self>

Options:
  -f, --force   Force removal even with uncommitted changes
  -h, --help    Show this help

Arguments:
  <path>        Worktree path or directory name
  self          Remove the worktree you're currently in

Examples:
  wt rm mh-260113-01          # Remove by directory name
  wt rm ../mh-260113-01-auth  # Remove by path
  wt rm self                  # Remove current worktree
  wt rm -f self               # Force remove current worktree
EOF
  exit 0
}

# ------------------------------------------------------------------------------
# New Command Functions
# ------------------------------------------------------------------------------

# Compute the next available sequence number for a given date prefix.
next_sequence() {
  local prefix="$1"
  local max=0
  local seq_num

  while IFS= read -r branch; do
    [[ -z "$branch" ]] && continue
    if [[ "$branch" =~ ^${prefix}/([0-9]+) ]]; then
      seq_num="${BASH_REMATCH[1]#0}"
      ((seq_num > max)) && max=$seq_num
    fi
  done < <(git branch --list "${prefix}/*" --format='%(refname:short)' 2>/dev/null)

  while IFS= read -r wt_path; do
    [[ -z "$wt_path" ]] && continue
    local wt_name
    wt_name="$(basename "$wt_path")"
    if [[ "$wt_name" =~ ^${prefix##*/}-([0-9]+) ]]; then
      seq_num="${BASH_REMATCH[1]#0}"
      ((seq_num > max)) && max=$seq_num
    fi
  done < <(git worktree list --porcelain 2>/dev/null | grep '^worktree ' | cut -d' ' -f2-)

  printf "%02d" $((max + 1))
}

validate_env_files() {
  local missing=()
  for env_file in "${ENV_FILES[@]}"; do
    [[ -f "${REPO_ROOT}/${env_file}" ]] || missing+=("$env_file")
  done

  if ((${#missing[@]} > 0)); then
    echo "error: missing required env files:" >&2
    printf "  - %s\n" "${missing[@]}" >&2
    exit 1
  fi
}

copy_env_files() {
  local target="$1"
  for env_file in "${ENV_FILES[@]}"; do
    local target_file="${target}/${env_file}"
    mkdir -p "$(dirname "$target_file")"
    cp "${REPO_ROOT}/${env_file}" "$target_file"
  done
}

open_iterm_tab() {
  local dir="$1"
  local cmd="$2"

  if ! command -v osascript &>/dev/null; then
    echo "warning: osascript not available, cannot open iTerm2 tab" >&2
    echo "run manually: cd '$dir' && $cmd" >&2
    return 1
  fi

  osascript <<EOF
tell application "iTerm2"
  activate
  tell current window
    create tab with default profile
    tell current session
      write text "cd '${dir}' && ${cmd}"
    end tell
  end tell
end tell
EOF
}

cmd_new() {
  local initials=""
  local launch_claude=false
  local description=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--initials)
        initials="${2:?missing value for --initials}"
        shift 2
        ;;
      -l|--launch)
        launch_claude=true
        shift
        ;;
      -h|--help)
        usage_new
        ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        description="$1"
        shift
        ;;
    esac
  done

  [[ -z "$initials" ]] && die "missing required option: -i/--initials"

  local date_prefix="${initials}/$(date +%y%m%d)"
  local sequence
  sequence="$(next_sequence "$date_prefix")"

  local branch_name dir_name
  if [[ -n "$description" ]]; then
    branch_name="${date_prefix}/${sequence}-${description}"
    dir_name="${initials}-$(date +%y%m%d)-${sequence}-${description}"
  else
    branch_name="${date_prefix}/${sequence}"
    dir_name="${initials}-$(date +%y%m%d)-${sequence}"
  fi

  local target_dir="${REPO_ROOT}/../${dir_name}"

  [[ -e "$target_dir" ]] && die "target path already exists: $target_dir"
  validate_env_files

  echo "Creating worktree..."
  echo "  Branch: $branch_name"
  echo "  Path:   $target_dir"
  git worktree add -b "$branch_name" "$target_dir"

  echo "Copying env files..."
  copy_env_files "$target_dir"

  echo "Installing dependencies..."
  (cd "$target_dir" && devbox run -- npm install)

  echo ""
  echo "Worktree ready:"
  echo "  cd $target_dir"

  if [[ "$launch_claude" == true ]]; then
    echo ""
    echo "Launching Claude Code in new iTerm2 tab..."
    open_iterm_tab "$target_dir" "claude --settings .claude/settings.json"
  fi
}

# ------------------------------------------------------------------------------
# Remove Command Functions
# ------------------------------------------------------------------------------

resolve_worktree_path() {
  local target="$1"

  # Handle "self" - current directory
  if [[ "$target" == "self" ]]; then
    local cwd
    cwd="$(pwd)"

    # Check if current directory is a worktree (not the main worktree)
    local main_worktree
    main_worktree="$(git worktree list --porcelain | head -1 | cut -d' ' -f2-)"

    if [[ "$cwd" == "$main_worktree" ]]; then
      die "cannot remove main worktree with 'self'"
    fi

    # Verify current directory is actually a worktree
    if ! git worktree list --porcelain | grep -q "^worktree ${cwd}$"; then
      die "current directory is not a worktree: $cwd"
    fi

    echo "$cwd"
    return
  fi

  # Handle relative names (just the directory name)
  if [[ "$target" != /* && "$target" != ../* ]]; then
    target="${REPO_ROOT}/../${target}"
  fi

  # Resolve to absolute path
  if [[ -d "$target" ]]; then
    (cd "$target" && pwd)
  else
    die "worktree not found: $target"
  fi
}

get_worktree_branch() {
  local target="$1"
  local branch=""
  local in_target=false

  while IFS= read -r line; do
    if [[ "$line" == "worktree ${target}" ]]; then
      in_target=true
    elif [[ "$in_target" == true && "$line" == branch* ]]; then
      branch="${line#branch refs/heads/}"
      break
    elif [[ "$in_target" == true && "$line" == worktree* ]]; then
      break
    fi
  done < <(git worktree list --porcelain)

  echo "$branch"
}

cmd_rm() {
  local force=false
  local target=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--force)
        force=true
        shift
        ;;
      -h|--help)
        usage_rm
        ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        target="$1"
        shift
        ;;
    esac
  done

  [[ -z "$target" ]] && die "missing worktree path or name. Use 'wt ls' to list worktrees."

  local resolved_path
  resolved_path="$(resolve_worktree_path "$target")"

  # Verify it's a worktree
  if ! git worktree list --porcelain | grep -q "^worktree ${resolved_path}$"; then
    die "not a git worktree: $resolved_path"
  fi

  local branch
  branch="$(get_worktree_branch "$resolved_path")"

  # If removing self, cd out first
  if [[ "$target" == "self" ]]; then
    echo "Leaving worktree directory..."
    cd "$REPO_ROOT"
  fi

  echo "Removing worktree: $resolved_path"

  if [[ "$force" == true ]]; then
    git worktree remove --force "$resolved_path"
  else
    git worktree remove "$resolved_path"
  fi

  if [[ -n "$branch" ]]; then
    echo "Removing branch: $branch"
    git branch -d "$branch" 2>/dev/null || {
      echo "warning: branch not deleted (may have unmerged changes)"
      echo "  to force delete: git branch -D '$branch'"
    }
  fi

  echo "Done."
}

# ------------------------------------------------------------------------------
# List Command
# ------------------------------------------------------------------------------

cmd_ls() {
  echo "Worktrees:"
  echo ""
  git worktree list
}

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------

[[ $# -eq 0 ]] && usage

case "${1:-}" in
  new)
    shift
    cmd_new "$@"
    ;;
  rm)
    shift
    cmd_rm "$@"
    ;;
  ls)
    cmd_ls
    ;;
  -h|--help)
    usage
    ;;
  *)
    die "unknown command: $1. Use 'new', 'rm', or 'ls'."
    ;;
esac
